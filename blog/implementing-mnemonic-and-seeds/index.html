<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta property='og:title' content='Implementing Mnemonics &amp; Seeds in Rust : BIP 39'/>
  <meta property='og:image' content='https:&#x2F;&#x2F;res.cloudinary.com&#x2F;vladimirfomene&#x2F;image&#x2F;upload&#x2F;c_scale,w_1180&#x2F;v1653069239&#x2F;blog&#x2F;mnemonic.jpg'/>
  <meta property='og:description' content='A mnemonic is a system&#x2F;device that helps with retention. This could be a pattern of letters, words, a phrase or even ideas. In our particular scenario we are trying to remember a very large number called a seed. This seed is used by wallets to derive all your keys and therefore calculate your balance.'/>
  <meta property='og:url' content='https:&#x2F;&#x2F;www.vladimirfomene.com&#x2F;blog&#x2F;implementing-mnemonic-and-seeds&#x2F;'/>
  <title>Bitcoin | Lightning Bytes</title>
  <link rel="stylesheet" href="/style.css">
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body>
  <header>
    <nav>
      <div>
        <span id="name"><a href="/">Vladimir Fomene</a></span>
        <span id="github" class="social-icon"><a href="https://github.com/vladimirfomene"><i class="fa fa-github-square"
              style="font-size:48px;"></i></a></span>
        <span id="twitter" class="social-icon"><a href="https://twitter.com/Vlad_kwasi"><i class="fa fa-twitter"
              style="font-size:48px;"></i></a></span>
        <span id="linkedin" class="social-icon"><a href="https://www.linkedin.com/in/vladimirfomene/"><i
              class="fa fa-linkedin" style="font-size:48px;"></i></a></span>
      </div>
    </nav>
  </header>
  <aside>
    <ul>
      <li><a href="https://vladimirfomene.com/blog/">Blog</a></li>
      <li><a href="https://vladimirfomene.com/project/">Projects</a></li>
      <li><a href="https://vladimirfomene.com/talk/">Talks</a></li>
    </ul>
  </aside>
  <section class="section">
    <div class="container">
      
<div id="section">
  <h1 class="title">
    Implementing Mnemonics &amp; Seeds in Rust : BIP 39
  </h1>
  <p class="subtitle"><strong>2022-05-13</strong></p>
  <h2 id="introduction">Introduction</h2>
<p>A mnemonic is a system/device that helps with retention. This could be a pattern of letters, words, a phrase or even ideas. In our particular scenario we are trying to remember a very large number called a seed. This seed is used by wallets to derive all your keys and therefore calculate your balance. When you download a wallet software, most wallets make you store a list of either 12 or 24 words as a backup for the wallet. With this setup, if you decide to suddenly change wallet software you can use this word list on the new wallet to recover your keys and calculate your balance. This list of words is called a mnemonic because it helps us remember or recover the seed. </p>
<p>Wallets that implement BIP 39 are able to recover your keys from the mnemonic. Most of them use 12 or 24 words, but it is also possible to use 15, 18 and 21 words.  Next, we will be looking at how we can generate our own mnemonic. To follow along download the codebase for the article <a href="https://github.com/vladimirfomene/bip39">here</a>.</p>
<h2 id="generate-entropy">Generate entropy</h2>
<p>Before we can generate a mnemonic phrase, we need to first generate cryptographically secure entropy (randomness). To do that, in the <code>entropy.rs</code> file, we create a new struct called <code>Entropy</code> with a field called <code>entropy</code> which has a vector of bytes as value. In the implementation of the struct, we created a new function which calls a cryptographically secured random number generator to generate the entropy. The code looks like this:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">impl </span><span>Entropy {
</span><span>
</span><span>  
</span><span>
</span><span>	</span><span style="color:#65737e;">//create new entropy (large random number)
</span><span>	</span><span style="color:#65737e;">//entropy size here is in bits.
</span><span>	</span><span style="color:#b48ead;">pub fn </span><span style="color:#8fa1b3;">new</span><span>(</span><span style="color:#bf616a;">size</span><span>: </span><span style="color:#b48ead;">usize</span><span>) -&gt; Entropy {
</span><span>
</span><span>		</span><span style="color:#65737e;">//Probably change this to a better error handling mechanism if this has
</span><span>
</span><span>		</span><span style="color:#65737e;">//to be a library.
</span><span>
</span><span>
</span><span>
</span><span>		</span><span style="color:#65737e;">//check if size is between 128 and 256
</span><span>
</span><span>		assert!((size &gt;= util::</span><span style="color:#d08770;">MIN_NUM_BITS</span><span>) &amp;&amp; (size &lt;= util::</span><span style="color:#d08770;">MAX_NUM_BITS</span><span>));
</span><span>
</span><span>
</span><span>
</span><span>		</span><span style="color:#65737e;">//check if size is a multiple of 32
</span><span>
</span><span>		assert!((size % util::</span><span style="color:#d08770;">ENTROPY_MULTIPLE</span><span>) == </span><span style="color:#d08770;">0</span><span>);
</span><span>
</span><span>
</span><span>
</span><span>		</span><span style="color:#65737e;">//create a vector filled with 0 bytes
</span><span>
</span><span>		</span><span style="color:#b48ead;">let mut</span><span> entropy: Vec&lt;</span><span style="color:#b48ead;">u8</span><span>&gt; = vec![</span><span style="color:#d08770;">0</span><span style="color:#b48ead;">u8</span><span>; size / util::</span><span style="color:#d08770;">BYTE_SIZE</span><span>];
</span><span>
</span><span>
</span><span>
</span><span>		</span><span style="color:#65737e;">//generate cryptographically secure random bytes and store it in entropy vector
</span><span>
</span><span>		rand::rngs::OsRng.</span><span style="color:#96b5b4;">try_fill_bytes</span><span>(&amp;</span><span style="color:#b48ead;">mut</span><span> entropy).</span><span style="color:#96b5b4;">unwrap</span><span>();
</span><span>
</span><span>
</span><span>
</span><span>		</span><span style="color:#b48ead;">return</span><span> Entropy {
</span><span>
</span><span>		entropy
</span><span>
</span><span>		}
</span><span>
</span><span>	}
</span><span>
</span><span>}
</span></code></pre>
<p>In the function, we make sure the bits used to generate entropy have are between 128 and 256 in size. This is enough bits to make sure that two people don't generate thesame entropy. There is also a check to make sure the size of these bits is a multiple of 32. Thirty two because it allows us to easily split the entropy in pieces and convert them to words. There after, we fill the vector of bytes by calling our cryptographically secured random number generator. Since we have a vector of bytes and not bits, our vector's length has to be <code>size</code> divided by the <code>BYTE_SIZE</code> . You can check the values of constants in the <code>util.rs</code> module.</p>
<h2 id="from-entropy-generate-checksum">From Entropy Generate Checksum</h2>
<p>According to the BIP, assuming the length in bits of the entropy is <code>ENT</code>. The checksum is the first <code>ENT / 32</code> bits of the SHA256 hash of the entropy.  For all our possible entropy len, we can have the following checksum size:</p>
<pre>
Let checksum size be, CS = ENT / 32.
The checksum size for all entropy length is as follows:

|  ENT  | CS | 
+-------+----+
|  128  |  4 | 
|  160  |  5 | 
|  192  |  6 | 
|  224  |  7 | 
|  256  |  8 | 
</pre>
<p><a href="https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki">Table Source</a></p>
<p>On the table we see that irrespective of the entropy length we choose, our checksum size will never be more than 8 (a byte). So to get the checksum, we generate a SHA256 hash of the entropy and take the first Byte.  Here is the code to generate the checksum from the entropy:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">generate_checksum</span><span>(</span><span style="color:#bf616a;">ent</span><span>: Entropy) -&gt; Vec&lt;</span><span style="color:#b48ead;">u8</span><span>&gt; {
</span><span>
</span><span>	</span><span style="color:#b48ead;">let mut</span><span> hasher = Sha256::new();
</span><span>
</span><span>	hasher.</span><span style="color:#96b5b4;">update</span><span>(&amp;ent.entropy);
</span><span>
</span><span>	</span><span style="color:#b48ead;">let</span><span> entropy_hash = hasher.</span><span style="color:#96b5b4;">finalize</span><span>();
</span><span>
</span><span>	</span><span style="color:#b48ead;">return</span><span> entropy_hash[</span><span style="color:#d08770;">0</span><span>..</span><span style="color:#d08770;">1</span><span>].</span><span style="color:#96b5b4;">to_owned</span><span>();
</span><span>
</span><span>}
</span></code></pre>
<h2 id="get-mnemonic-from-entropy-and-checksum">Get Mnemonic from entropy and checksum</h2>
<p>Now that we have an entropy and its checksum, we can calculate a mnemonic. Let the word count of a mnemonic be <code>WC</code>. The word count for each entropy length is calculated like <code>WC = (ENT + CS) / 11</code> where <code>ENT</code> is the entropy length and <code>CS</code> is the checksum's length. This can be represented with the following table:</p>
<pre>
WC = (ENT + CS) / 11

|  ENT  | CS | ENT+CS |  WC  |
+-------+----+--------+------+
|  128  |  4 |   132  |  12  |
|  160  |  5 |   165  |  15  |
|  192  |  6 |   198  |  18  |
|  224  |  7 |   231  |  21  |
|  256  |  8 |   264  |  24  |
</pre>
<p><a href="https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki">Table Source</a></p>
<p>Base on the formula for <code>WC</code> above we have divided our concatenated entropy and checksum bits into chunks of <strong>11</strong> bits. Therefore, our words are represented by 11 bits numbers. With 11 bits, we can represent 2048 (2^11) numbers. These numbers can be from 0 to 2047. Each of these numbers is an index in our array of 2048 words found in <code>src/language/english.rs</code>. This works because the word list is defined in the <a href="https://github.com/bitcoin/bips/blob/master/bip-0039/english.txt">spec</a>. If everyone created their own word list wallets won't be compatible. We used the following snippet of code from the <code>src/mnemonic.rs</code> module to generate our mnemonic words.</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">impl </span><span>Mnemonic {
</span><span>
</span><span>  
</span><span>
</span><span>	</span><span style="color:#b48ead;">pub fn </span><span style="color:#8fa1b3;">from_entropy_checksum</span><span>(</span><span style="color:#bf616a;">entropy</span><span>: Vec&lt;</span><span style="color:#b48ead;">u8</span><span>&gt;, </span><span style="color:#bf616a;">checksum</span><span>: Vec&lt;</span><span style="color:#b48ead;">u8</span><span>&gt;) -&gt; Mnemonic {
</span><span>
</span><span>		</span><span style="color:#b48ead;">let</span><span> checksum_size = (entropy.</span><span style="color:#96b5b4;">len</span><span>() * util::</span><span style="color:#d08770;">BYTE_SIZE</span><span>) / util::</span><span style="color:#d08770;">ENTROPY_MULTIPLE</span><span>;
</span><span>
</span><span>		</span><span style="color:#b48ead;">let</span><span> entropy_size = entropy.</span><span style="color:#96b5b4;">len</span><span>() * util::</span><span style="color:#d08770;">BYTE_SIZE</span><span>;
</span><span>
</span><span>		</span><span style="color:#b48ead;">let</span><span> mnemonic_word_count = (entropy_size + checksum_size) / util::</span><span style="color:#d08770;">WORD_BITS</span><span>;
</span><span>
</span><span>
</span><span>
</span><span>		</span><span style="color:#65737e;">//create a vector of bits where
</span><span>
</span><span>		</span><span style="color:#b48ead;">let mut</span><span> bits = vec![</span><span style="color:#d08770;">false</span><span>; entropy_size + checksum_size];
</span><span>
</span><span>
</span><span>
</span><span>		</span><span style="color:#65737e;">//add entropy bits to bits array
</span><span>
</span><span>		</span><span style="color:#b48ead;">for </span><span>(index, bit) in bits[..(entropy.</span><span style="color:#96b5b4;">len</span><span>() * util::</span><span style="color:#d08770;">BYTE_SIZE</span><span>)].</span><span style="color:#96b5b4;">iter_mut</span><span>().</span><span style="color:#96b5b4;">enumerate</span><span>(){
</span><span>
</span><span>		*bit = util::get_index_bit(entropy[index / util::</span><span style="color:#d08770;">BYTE_SIZE</span><span>], index % util::</span><span style="color:#d08770;">BYTE_SIZE</span><span>);
</span><span>
</span><span>		}
</span><span>
</span><span>
</span><span>
</span><span>		</span><span style="color:#65737e;">//add checksum bits to bits array
</span><span>
</span><span>		</span><span style="color:#b48ead;">for </span><span>(index, bit) in bits[(entropy.</span><span style="color:#96b5b4;">len</span><span>() * util::</span><span style="color:#d08770;">BYTE_SIZE</span><span>)..].</span><span style="color:#96b5b4;">iter_mut</span><span>().</span><span style="color:#96b5b4;">enumerate</span><span>() {
</span><span>
</span><span>		*bit = util::get_index_bit(checksum[</span><span style="color:#d08770;">0</span><span>], index);
</span><span>
</span><span>		}
</span><span>
</span><span>
</span><span>
</span><span>		</span><span style="color:#65737e;">//create vector for mnemonic words.
</span><span>
</span><span>		</span><span style="color:#b48ead;">let mut</span><span> mnemonic_list = Vec::with_capacity(mnemonic_word_count);
</span><span>
</span><span>		</span><span style="color:#b48ead;">for</span><span> chunk in bits[..(checksum_size + entropy_size)].</span><span style="color:#96b5b4;">chunks</span><span>(</span><span style="color:#d08770;">11</span><span>) {
</span><span>
</span><span>		</span><span style="color:#65737e;">//convert 11 bit chunk to word index
</span><span>
</span><span>		</span><span style="color:#b48ead;">let</span><span> word_index = util::bits_to_usize(chunk, </span><span style="color:#d08770;">11</span><span>);
</span><span>
</span><span>
</span><span>
</span><span>		</span><span style="color:#65737e;">//use word index to get word from wordlist
</span><span>
</span><span>		</span><span style="color:#b48ead;">let</span><span> word = english::</span><span style="color:#d08770;">WORDS</span><span>[word_index];
</span><span>
</span><span>
</span><span>
</span><span>		</span><span style="color:#65737e;">//add word to mnemonic list
</span><span>
</span><span>		mnemonic_list.</span><span style="color:#96b5b4;">push</span><span>(word.</span><span style="color:#96b5b4;">to_string</span><span>());
</span><span>
</span><span>		}
</span><span>
</span><span>
</span><span>		</span><span style="color:#b48ead;">return</span><span> Mnemonic {
</span><span>
</span><span>			lang: language::Language::English,
</span><span>
</span><span>			words: mnemonic_list
</span><span>
</span><span>		}
</span><span>
</span><span>	}
</span><span>
</span><span>}
</span></code></pre>
<h2 id="generate-seed-from-mnemonic">Generate Seed from Mnemonic</h2>
<p>With the above code, we have been able to generate our list of mnemonic words from our english wordlist. Now we are going to pass our mnemonics through a password based key derivation function (PBKDF2 for short).  This key derivation function uses HMAC-SHA512 as its pseudo-random function. The <code>password</code> that we are going to hash is the mnemonic sentence. The salt is the  <code>&quot;mnemonic&quot; + passphrase</code> where the passphrase can be empty. This algorithm(PBKDF2) will produce different seeds from the same mnemonic if given different passphrases. We are going to use 2048 iterations in our PBKDF2. This just refers to the number of times we are going to be hashing. One important thing to mention here is that the <code>salt</code> and <code>password</code> have to be UTF-8 normalized before passing it to this function. Normalization is important because it prevents our program from treating words looking thesame differently because they have different Unicode representation. See more <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize">here</a>. Here is the code snippet for generating a seed from a mnemonic.</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">pub </span><span>(</span><span style="color:#b48ead;">crate</span><span>) </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">compute_seed</span><span>(</span><span style="color:#bf616a;">mnemonic</span><span>: Vec&lt;String&gt;, </span><span style="color:#bf616a;">passphrase</span><span>: &amp;</span><span style="color:#b48ead;">str</span><span>) -&gt; Vec&lt;</span><span style="color:#b48ead;">u8</span><span>&gt;{
</span><span>
</span><span>  
</span><span>	</span><span style="color:#65737e;">//join our mnemonic words into one sentence
</span><span>	</span><span style="color:#b48ead;">let</span><span> mnemonic_sentence = mnemonic.</span><span style="color:#96b5b4;">join</span><span>(&quot; &quot;);
</span><span>
</span><span>	</span><span style="color:#65737e;">//use the unicode-normalization crate to normalize string
</span><span>	</span><span style="color:#b48ead;">let</span><span> normalized_mnemonic = mnemonic_sentence.</span><span style="color:#96b5b4;">nfkd</span><span>().collect::&lt;String&gt;();
</span><span>
</span><span>	</span><span style="color:#65737e;">//convert normalized string to bytes
</span><span>	</span><span style="color:#b48ead;">let</span><span> normalized_mnemonic = normalized_mnemonic.</span><span style="color:#96b5b4;">as_bytes</span><span>();
</span><span>
</span><span>	</span><span style="color:#65737e;">//create salt from prefix and passphrase
</span><span>	</span><span style="color:#b48ead;">let</span><span> salt = format!(&quot;</span><span style="color:#d08770;">{}{}</span><span>&quot;, </span><span style="color:#d08770;">SALT_PREFIX</span><span>, passphrase);
</span><span>	
</span><span>	</span><span style="color:#65737e;">//normalize salt string
</span><span>	</span><span style="color:#b48ead;">let</span><span> normalized_salt = salt.</span><span style="color:#96b5b4;">nfkd</span><span>().collect::&lt;String&gt;();
</span><span>
</span><span>	</span><span style="color:#65737e;">//convert salt string to bytes
</span><span>	</span><span style="color:#b48ead;">let</span><span> normalized_salt = normalized_salt.</span><span style="color:#96b5b4;">as_bytes</span><span>();
</span><span>
</span><span>	</span><span style="color:#65737e;">//create a seed vector to hold seed bytes
</span><span>	</span><span style="color:#b48ead;">let mut</span><span> seed = [</span><span style="color:#d08770;">0</span><span style="color:#b48ead;">u8</span><span>; </span><span style="color:#d08770;">PBKDF2_BYTES</span><span>];
</span><span>
</span><span>	</span><span style="color:#65737e;">//call PBKDF2 to generate seed and store it in seed vector
</span><span>	pbkdf2::pbkdf2::&lt;Hmac&lt;Sha512&gt;&gt;(normalized_mnemonic, normalized_salt, </span><span style="color:#d08770;">PBKDF2_ITERATIONS </span><span>as </span><span style="color:#b48ead;">u32</span><span>, &amp;</span><span style="color:#b48ead;">mut</span><span> seed);
</span><span>
</span><span>	</span><span style="color:#b48ead;">return</span><span> seed.</span><span style="color:#96b5b4;">to_vec</span><span>();
</span><span>}
</span></code></pre>
<h2 id="conclusion">Conclusion</h2>
<p>In this article, we have shown how to move from entropy, to checksum, to mnemonic and from mnemonic to seed. A BIP39 Mnemonic is a list of words used as backup by wallets. By backup, I mean it can be used by any BIP39 compatible wallet software to recover your keys and therefore calculate your balance.</p>
<h2 id="references">References</h2>
<p>While working on this article, I learned a lot while reading the following implementations alongside the BIP 39 Wiki. </p>
<ul>
<li><a href="https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki">BIP 39 Wiki</a></li>
<li><a href="https://github.com/vladimirfomene/bip39">Article Code</a></li>
<li><a href="https://github.com/koushiro/bip0039">Alternative Implementation</a></li>
<li><a href="https://github.com/rust-bitcoin/rust-bip39">Alternative Implementation</a></li>
</ul>

</div>

    </div>
  </section>
</body>

</html>